<!doctype html>
<meta charset="utf-8">
<title>Chat Admin</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  :root{--bg:#0b0b0b;--fg:#f2f2f2;--mut:#9aa0a6;--card:#151515;--br:#2a2a2a;--acc:#4da3ff}
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:14px 18px;border-bottom:1px solid var(--br);display:grid;gap:10px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,button{padding:8px 10px;border:1px solid var(--br);border-radius:8px;background:#111;color:#fff}
  button{cursor:pointer} button:hover{border-color:#3a3a3a}
  main{padding:18px;display:grid;gap:18px;grid-template-columns:1fr 1fr}
  @media (max-width:1100px){main{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--br);border-radius:12px;overflow:hidden}
  .card h2{margin:0;padding:10px 12px;border-bottom:1px solid var(--br);font-size:15px}
  table{border-collapse:collapse;width:100%}
  th,td{border-top:1px solid var(--br);padding:8px 10px;vertical-align:top}
  th{background:#121212;text-align:left;position:sticky;top:0}
  .mut{color:var(--mut)}
  .rooms{display:grid;grid-template-columns:repeat(auto-fill,minmax(380px,1fr));gap:14px;padding:12px}
  .room{border:1px solid var(--br);border-radius:10px;background:#101010;display:flex;flex-direction:column;min-height:260px}
  .room-h{padding:8px 10px;background:#121212;border-bottom:1px solid var(--br);display:flex;gap:8px;align-items:center}
  .badge{padding:2px 8px;border-radius:999px;background:#1d2633;color:#bcd7ff;font-size:12px;margin-left:6px}
  .log{font:12px/1.5 ui-monospace,SFMono-Regular,Consolas,Menlo,monospace;background:#0b0b0b;color:#e9e9e9;padding:8px 10px;overflow:auto;white-space:pre-wrap;word-break:break-word}
  a{color:var(--acc);text-decoration:none} a:hover{text-decoration:underline}
</style>
<header>
  <div class="row">
    <b>Server:</b><input id="base" placeholder="https://your-render.onrender.com" style="min-width:360px">
    <b>CONN_TOKEN:</b><input id="connTok" placeholder="required for /connections.json, /rooms.json">
    <b>LOGS_TOKEN:</b><input id="logsTok" placeholder="required for logs + WS monitor">
    <button id="apply">Apply</button>
    <span class="mut">Poll 2s; logs backfill once, then live-stream.</span>
  </div>
  <div class="row">
    <label>Filter room: <input id="roomFilter" placeholder="(blank = all)"></label>
    <button id="applyFilter">Apply</button>
    <label>Add room: <input id="manualRoom" placeholder="ffa:party:TAG"></label>
    <button id="addRoom">Monitor</button>
  </div>
</header>

<main>
  <section class="card">
    <h2>Connections</h2>
    <div style="max-height:60vh;overflow:auto">
      <table id="tbl">
        <thead><tr><th>#</th><th>Room</th><th>Name</th><th>IP</th><th>Key</th></tr></thead>
        <tbody></tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h2>Room Logs</h2>
    <div id="rooms" class="rooms"></div>
  </section>
</main>

<script>
const base   = document.getElementById('base');
const connEl = document.getElementById('connTok');
const logsEl = document.getElementById('logsTok');
const apply  = document.getElementById('apply');
const filt   = document.getElementById('roomFilter');
const applyF = document.getElementById('applyFilter');
const manual = document.getElementById('manualRoom');
const addBtn = document.getElementById('addRoom');
const tbody  = document.querySelector('#tbl tbody');
const rooms  = document.getElementById('rooms');

function httpBase(){ return base.value.replace(/\/+$/,''); }
function httpToWs(b){
  const clean = b.replace(/\/+$/,'');
  if (/^https:\/\//i.test(clean)) return clean.replace(/^https:/,'wss:') + '/chat';
  if (/^http:\/\//i.test(clean))  return clean.replace(/^http:/,'ws:')  + '/chat';
  if (/^wss?:\/\//i.test(clean))  return clean.endsWith('/chat') ? clean : (clean + '/chat');
  return 'ws://' + clean + '/chat';
}

const sockets  = new Map();
const buffers  = new Map();
const hydrated = new Map();
const paused   = new Map();
const MAX = 500;

function card(room){
  let c = document.querySelector(`[data-room="${CSS.escape(room)}"]`);
  if (c) return c;
  c = document.createElement('div');
  c.className='room'; c.dataset.room = room;
  c.innerHTML = `
    <div class="room-h"><b>${room}</b> <span class="badge" data-b="${room}">0</span>
      <span style="margin-left:auto"></span>
      <button data-pause="${room}">Pause</button>
      <button data-clear="${room}">Clear</button>
      <button data-reco="${room}">Reconnect</button>
      <button data-pull="${room}">Pull history</button>
      <button data-wipe="${room}">Wipe server logs</button>
    </div>
    <div class="log" data-log="${room}"></div>`;
  rooms.appendChild(c);
  c.querySelector(`[data-pause="${CSS.escape(room)}"]`).onclick = (e)=> paused.set(room, !paused.get(room));
  c.querySelector(`[data-clear="${CSS.escape(room)}"]`).onclick = ()=>{ buffers.set(room, []); paint(room); };
  c.querySelector(`[data-reco="${CSS.escape(room)}"]`).onclick = ()=> reconnect(room);
  c.querySelector(`[data-pull="${CSS.escape(room)}"]`).onclick = ()=> hydrate(room, true);
  c.querySelector(`[data-wipe="${CSS.escape(room)}"]`).onclick = async ()=>{
    await fetch(httpBase()+'/logs/clear?room='+encodeURIComponent(room), {
      method:'GET', headers:{'x-logs-token': logsEl.value}, cache:'no-store'
    });
    buffers.set(room,[]); hydrated.set(room,false); paint(room);
  };
  return c;
}
function push(room, m){
  if (!buffers.has(room)) buffers.set(room,[]);
  const a = buffers.get(room);
  a.push(m); if (a.length>MAX) a.splice(0,a.length-MAX);
  if (!paused.get(room)) paint(room);
}
function paint(room){
  const log = document.querySelector(`[data-log="${CSS.escape(room)}"]`);
  const b   = document.querySelector(`[data-b="${CSS.escape(room)}"]`);
  const arr = buffers.get(room) || [];
  b.textContent = String(arr.length);
  log.innerHTML = arr.map(x=>`<div>[${new Date(x.ts).toTimeString().slice(0,8)}] <b>${(x.from||'•')}</b> ${x.text||''}</div>`).join('');
  log.scrollTop = log.scrollHeight;
}
async function hydrate(room, force=false){
  if (hydrated.get(room) && !force) return;
  try{
    const r = await fetch(httpBase()+'/logs.json?room='+encodeURIComponent(room), {
      headers:{'x-logs-token': logsEl.value}, cache:'no-store'
    });
    const j = await r.json();
    buffers.set(room, (j.messages||[]).slice(-MAX));
    hydrated.set(room,true);
    paint(room);
  }catch{}
}
function connect(room){
  if (sockets.has(room)) return;
  hydrate(room);
  const u = new URL(httpToWs(httpBase()));
  u.searchParams.set('room', room);
  u.searchParams.set('name','Monitor');
  u.searchParams.set('token', logsEl.value); // prove we’re allowed to monitor
  const ws = new WebSocket(u.toString());
  sockets.set(room, ws);
  card(room);
  ws.onopen    = ()=> push(room, {ts:Date.now(), from:'•', text:'[monitor] connected'});
  ws.onclose   = ()=> { push(room,{ts:Date.now(), from:'•', text:'[monitor] disconnected'}); sockets.delete(room); };
  ws.onerror   = ()=> push(room, {ts:Date.now(), from:'•', text:'[monitor] error'});
  ws.onmessage = (ev)=>{
    try{
      const d = JSON.parse(ev.data);
      if (d.type==='msg') push(room, {ts: d.ts||Date.now(), from:d.from||'??', text:d.text||''});
    }catch{ push(room,{ts:Date.now(), from:'•', text:String(ev.data||'')}); }
  };
}
function reconnect(room){ try{ sockets.get(room)?.close(); }catch{} sockets.delete(room); connect(room); }

async function tick(){
  // connections table
  const room = filt.value.trim();
  const qs = room ? ('?room='+encodeURIComponent(room)) : '';
  try{
    const r = await fetch(httpBase()+'/connections.json'+qs, {
      headers:{'x-conn-token': connEl.value}, cache:'no-store'
    });
    const j = await r.json();
    tbody.innerHTML='';
    (j.clients||[]).forEach((c,i)=>{
      const tr = document.createElement('tr');
      tr.innerHTML =
        `<td>${i+1}</td><td>${c.room||''}</td><td>${c.name||''}</td><td>${c.ip||''}</td><td>${c.key||''}</td>`;
      tbody.appendChild(tr);
    });
    document.title = 'Chat Admin ('+ (j.count||0) +')';
  }catch{}

  // rooms list
  try{
    const rr = await fetch(httpBase()+'/rooms.json', {
      headers:{'x-conn-token': connEl.value}, cache:'no-store'
    });
    const jr = await rr.json();
    const set = new Set(jr.rooms||[]);
    const f = filt.value.trim(); if (f) { for (const r of [...set]) if (!r.includes(f)) set.delete(r); }
    set.forEach(rm=>{ card(rm); connect(rm); });
    for (const [rm] of sockets) if (!set.has(rm)) { try{sockets.get(rm)?.close();}catch{} sockets.delete(rm); }
  }catch{}
}

apply.onclick = ()=>{ sockets.forEach(ws=>{ try{ws.close();}catch{} }); sockets.clear(); hydrated.clear(); tick(); };
applyF.onclick = tick;
addRoom.onclick = ()=>{ const rm = manual.value.trim(); if (!rm) return; card(rm); connect(rm); manual.value=''; };

// defaults
base.value = location.origin;
setInterval(tick, 2000);
tick();
</script>
