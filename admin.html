<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Chat Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    :root{
      --bg:#0b0b0b; --fg:#f2f2f2; --muted:#9aa0a6; --card:#151515; --border:#2a2a2a; --accent:#4da3ff;
      --ok:#09b57f; --err:#e24d52; --warn:#e0a84f;
    }
    *{box-sizing:border-box}
    body{margin:0; background:var(--bg); color:var(--fg); font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    header{padding:14px 18px; border-bottom:1px solid var(--border); display:flex; gap:14px; align-items:center; flex-wrap:wrap}
    header h1{font-size:18px; margin:0; font-weight:700}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    input[type="text"], input[type="search"], input[type="password"]{
      padding:8px 10px; background:#0f0f10; border:1px solid var(--border); color:#f2f2f2; border-radius:8px; width:420px; max-width:100%
    }
    button,select{padding:8px 10px; border:1px solid var(--border); background:#121314; color:#f2f2f2; border-radius:8px; cursor:pointer}
    button:hover{border-color:#3a3a3a}
    main{padding:18px}
    .grid3{display:grid; grid-template-columns: 1fr 1fr 420px; gap:18px}
    @media (max-width: 1350px){ .grid3{grid-template-columns: 1fr 1fr} }
    @media (max-width: 980px){ .grid3{grid-template-columns: 1fr} }

    .card{background:var(--card); border:1px solid var(--border); border-radius:12px; overflow:hidden; min-height:260px; position:relative}
    .card h2{margin:0; padding:10px 12px; border-bottom:1px solid var(--border); font-size:15px}
    table{border-collapse:collapse; width:100%}
    th,td{border-top:1px solid var(--border); padding:8px 10px; vertical-align:top}
    th{background:#121212; text-align:left; position:sticky; top:0}
    .muted{color:var(--muted)}
    .rooms{display:grid; grid-template-columns: repeat(auto-fill, minmax(380px, 1fr)); gap:14px; padding:12px; max-height:60vh; overflow:auto}
    .room{border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#101010; display:flex; flex-direction:column; height:360px}
    .room-h{padding:8px 10px; background:#121212; border-bottom:1px solid var(--border); display:flex; gap:8px; align-items:center}
    .room-h b{font-weight:700}
    .badge{display:inline-block; padding:2px 8px; border-radius:999px; background:#1d2633; color:#bcd7ff; font-size:12px; margin-left:6px}
    .actions{margin-left:auto; display:flex; gap:6px; align-items:center; flex-wrap:wrap}
    .log{font:12px/1.5 ui-monospace,SFMono-Regular,Consolas,Menlo,monospace; background:#0b0b0b; color:#e9e9e9;
         padding:8px 10px; overflow:auto; flex:1; white-space:pre-wrap; word-break:break-word}
    .line time{color:#8a8a8a; margin-right:6px}
    .line .from{font-weight:700; margin-right:6px; color:#d7e3ff}
    a{color:var(--accent); text-decoration:none}
    a:hover{text-decoration:underline}

    /* Keys UI */
    .stack{display:flex; flex-direction:column; gap:10px; padding:12px}
    .row2{display:flex; gap:8px; flex-wrap:wrap}
    .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px}
    .pill.active{background:var(--ok); color:#fff}
    .pill.revoked{background:var(--err); color:#fff}
    .small{font-size:12px}
    .hint{color:var(--muted); font-size:12px}
    .btn-warn{border-color:#4a3818; background:#2a1f0b}
    .btn-danger{border-color:#4a1818; background:#2a0b0b}
    .btn-ok{border-color:#134a35; background:#0e2a20}
    .list{max-height:54vh; overflow:auto}
    .nowrap{white-space:nowrap}

    /* lock overlay */
    .lockbox{
      position:absolute; inset:auto 12px 12px 12px;
      border:1px dashed var(--border); background:#0b0b0bcc;
      padding:12px; border-radius:10px; display:flex; gap:10px; align-items:center; justify-content:space-between;
    }
  </style>
</head>
<body>
  <header>
    <h1>Chat Admin</h1>
    <div class="row">
      <label>Server URL:
        <input id="base" type="text" placeholder="e.g. https://chat-smge.onrender.com">
      </label>
      <button id="applyBase">Apply</button>
      <span class="muted">Connections poll every 2s. Logs backfill once, then stream live.</span>
    </div>
    <div class="row">
      <label>Filter room:
        <input id="roomFilter" type="text" placeholder="(leave blank for all)">
      </label>
      <button id="applyFilter">Apply</button>
      <label>Add room:
        <input id="manualRoom" type="text" placeholder="ffa:party:TAG">
      </label>
      <button id="addRoom">Add monitor</button>
    </div>
  </header>

  <main class="grid3">
    <!-- Connections -->
    <section class="card" id="connCard">
      <h2>Connections</h2>
      <div style="max-height:60vh; overflow:auto">
        <table id="tbl">
          <thead>
            <tr><th>#</th><th>Room</th><th>Name</th><th>IP</th><th>Key</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="lockbox" id="connLock" style="display:none">
        <span class="muted">Locked. Set a <b>Connections Token</b> to view.</span>
        <div class="row2">
          <input id="connTokInline" type="password" placeholder="Connections Token">
          <button id="saveConnTokInline" class="btn-ok">Save</button>
        </div>
      </div>
    </section>

    <!-- Room Logs -->
    <section class="card" id="logsCard">
      <h2>Room Logs</h2>
      <div id="rooms" class="rooms"></div>
      <div class="lockbox" id="logsLock" style="display:none">
        <span class="muted">Locked. Set a <b>Logs Token</b> to view room logs.</span>
        <div class="row2">
          <input id="logsTokInline" type="password" placeholder="Logs Token">
          <button id="saveLogsTokInline" class="btn-ok">Save</button>
        </div>
      </div>
    </section>

    <!-- Keys -->
    <section class="card">
      <h2>Keys</h2>
      <div class="stack">
        <div class="row2">
          <label class="nowrap">Admin Token:
            <input id="admTok" type="password" placeholder="paste once (stored locally)">
          </label>
          <button id="saveTok" class="btn-ok">Save</button>
          <span class="hint">Stored in your browser’s localStorage.</span>
        </div>

        <div class="row2">
          <label class="nowrap">Connections Token:
            <input id="connTok" type="password" placeholder="protects connections view">
          </label>
          <button id="saveConnTok" class="btn-ok">Save</button>
        </div>

        <div class="row2">
          <label class="nowrap">Logs Token:
            <input id="logsTok" type="password" placeholder="protects logs + monitors">
          </label>
          <button id="saveLogsTok" class="btn-ok">Save</button>
        </div>

        <div class="row2">
          <label>Label:
            <input id="keyLabel" type="text" placeholder="e.g. Hasan, Friend-1">
          </label>
          <button id="genKey" class="btn-ok">Generate</button>
        </div>

        <div class="row2">
          <input id="keyFilter" type="search" placeholder="Filter keys (label or key)">
          <button id="refreshKeys">Refresh</button>
        </div>

        <div class="list">
          <table style="width:100%">
            <thead>
              <tr>
                <th>Label</th>
                <th>Key</th>
                <th>Status</th>
                <th>Created</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="keysTbody"></tbody>
          </table>
        </div>

        <div id="keyMsg" class="hint"></div>
      </div>
    </section>
  </main>

<script>
/* ======== helpers/tokens ======== */
function httpBase() { return baseInput.value.replace(/\/+$/,''); }
function httpToWs(base) {
  const clean = base.replace(/\/+$/,'');
  if (/^https:\/\//i.test(clean)) return clean.replace(/^https:/,'wss:') + '/chat';
  if (/^http:\/\//i.test(clean))  return clean.replace(/^http:/,'ws:')  + '/chat';
  if (/^wss?:\/\//i.test(clean))  return clean.endsWith('/chat') ? clean : (clean + '/chat');
  return 'ws://' + clean + '/chat';
}
function fmtTime(ts){
  const d = new Date(ts); const h = String(d.getHours()).padStart(2,'0');
  const m = String(d.getMinutes()).padStart(2,'0'); const s = String(d.getSeconds()).padStart(2,'0');
  return `${h}:${m}:${s}`;
}
function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }

function token(){ return localStorage.getItem('chat_admin_token') || ''; }
function setToken(v){ localStorage.setItem('chat_admin_token', v || ''); }
function connToken(){ return localStorage.getItem('chat_conn_token') || ''; }
function setConnToken(v){ localStorage.setItem('chat_conn_token', v || ''); }
function logsToken(){ return localStorage.getItem('chat_logs_token') || ''; }
function setLogsToken(v){ localStorage.setItem('chat_logs_token', v || ''); }

/* ======== elements ======== */
const baseInput = document.getElementById('base');
const applyBaseBtn = document.getElementById('applyBase');
const filterInput = document.getElementById('roomFilter');
const applyFilterBtn = document.getElementById('applyFilter');
const manualRoomInput = document.getElementById('manualRoom');
const addRoomBtn = document.getElementById('addRoom');

const tableBody = document.querySelector('#tbl tbody');
const roomsGrid = document.getElementById('rooms');

const connCard = document.getElementById('connCard');
const logsCard = document.getElementById('logsCard');
const connLock = document.getElementById('connLock');
const logsLock = document.getElementById('logsLock');
const connTokInline = document.getElementById('connTokInline');
const logsTokInline = document.getElementById('logsTokInline');
const saveConnTokInline = document.getElementById('saveConnTokInline');
const saveLogsTokInline = document.getElementById('saveLogsTokInline');

const tokInput = document.getElementById('admTok');
const saveTokBtn = document.getElementById('saveTok');
const connTok = document.getElementById('connTok');
const saveConnTok = document.getElementById('saveConnTok');
const logsTok = document.getElementById('logsTok');
const saveLogsTok = document.getElementById('saveLogsTok');

const keyLabel = document.getElementById('keyLabel');
const genKeyBtn = document.getElementById('genKey');
const keyFilter = document.getElementById('keyFilter');
const refreshKeysBtn = document.getElementById('refreshKeys');
const keysTbody = document.getElementById('keysTbody');
const keyMsg = document.getElementById('keyMsg');

/* ======== state & sockets for room monitors ======== */
const sockets = new Map();   // room -> WebSocket
const paused  = new Map();   // room -> boolean
const buffers = new Map();   // room -> [{ts,from,text}]
const hydrated = new Map();  // room -> boolean (history loaded once)
const MAX_LINES = 500;

/* ======== lock UI helpers ======== */
function updateLocks(){
  const hasConn = !!connToken();
  const hasLogs = !!logsToken();
  connLock.style.display = hasConn ? 'none' : 'flex';
  logsLock.style.display = hasLogs ? 'none' : 'flex';
  // if locked, clear visible content
  if (!hasConn){
    tableBody.innerHTML = '<tr><td colspan="6" class="muted">Locked. Save a Connections Token to view.</td></tr>';
    document.title = 'Chat Admin';
  }
  if (!hasLogs){
    roomsGrid.innerHTML = '';
    // also close any existing room sockets for safety
    sockets.forEach(ws => { try{ ws.close(); }catch{} });
    sockets.clear();
  }
}

/* ======== UI events ======== */
saveConnTokInline.addEventListener('click', ()=>{
  setConnToken(connTokInline.value.trim()); connTok.value = connToken(); updateLocks(); loadConnectionsAndRooms();
});
saveLogsTokInline.addEventListener('click', ()=>{
  setLogsToken(logsTokInline.value.trim()); logsTok.value = logsToken(); updateLocks(); loadConnectionsAndRooms();
});

tokInput.value = token();
connTok.value = connToken();
logsTok.value = logsToken();

saveTokBtn.addEventListener('click', ()=>{
  setToken(tokInput.value.trim());
  keyMsg.textContent = 'Admin token saved ✔';
  setTimeout(()=> keyMsg.textContent = '', 1500);
});
saveConnTok.addEventListener('click', ()=>{
  setConnToken(connTok.value.trim());
  updateLocks(); loadConnectionsAndRooms();
});
saveLogsTok.addEventListener('click', ()=>{
  setLogsToken(logsTok.value.trim());
  updateLocks(); loadConnectionsAndRooms();
});

applyBaseBtn.addEventListener('click', () => {
  sockets.forEach(ws => { try{ ws.close(); }catch{} });
  sockets.clear();
  hydrated.clear();
  loadConnectionsAndRooms();
});
applyFilterBtn.addEventListener('click', loadConnectionsAndRooms);
addRoomBtn.addEventListener('click', () => {
  if (!logsToken()){ updateLocks(); return; }
  const rm = manualRoomInput.value.trim();
  if (!rm) return;
  ensureRoomCard(rm);
  connectRoom(rm);
  manualRoomInput.value = '';
});

// default Server URL = same origin
baseInput.value = location.origin;

/* ======== render helpers ======== */
function ensureRoomCard(room) {
  let card = document.querySelector(`[data-room="${CSS.escape(room)}"]`);
  if (card) return card;

  card = document.createElement('div');
  card.className = 'room';
  card.dataset.room = room;
  card.innerHTML = `
    <div class="room-h">
      <b>${escapeHtml(room)}</b>
      <span class="badge" data-badge="${escapeHtml(room)}">0</span>
      <div class="actions">
        <label><input type="checkbox" data-pause="${escapeHtml(room)}"> Pause</label>
        <button data-clear="${escapeHtml(room)}">Clear</button>
        <button data-reconnect="${escapeHtml(room)}">Reconnect</button>
        <button data-pull="${escapeHtml(room)}">Pull history</button>
        <button data-wipe="${escapeHtml(room)}">Wipe server logs</button>
      </div>
    </div>
    <div class="log" data-log="${escapeHtml(room)}"></div>
  `;
  roomsGrid.appendChild(card);

  card.querySelector(`[data-pause="${CSS.escape(room)}"]`).addEventListener('change', (e)=>{
    paused.set(room, e.target.checked);
  });
  card.querySelector(`[data-clear="${CSS.escape(room)}"]`).addEventListener('click', ()=>{
    buffers.set(room, []);
    paintRoom(room);
  });
  card.querySelector(`[data-reconnect="${CSS.escape(room)}"]`).addEventListener('click', ()=>{
    reconnectRoom(room);
  });
  card.querySelector(`[data-pull="${CSS.escape(room)}"]`).addEventListener('click', ()=>{
    hydrateRoom(room, true);
  });
  card.querySelector(`[data-wipe="${CSS.escape(room)}"]`).addEventListener('click', async ()=>{
    try {
      await fetch(httpBase() + '/logs/clear?room=' + encodeURIComponent(room), {
        cache:'no-store',
        headers:{ 'x-logs-token': logsToken() }
      });
    } catch {}
    buffers.set(room, []);
    hydrated.set(room, false);
    paintRoom(room);
  });

  return card;
}

function paintRoom(room){
  const logEl = document.querySelector(`[data-log="${CSS.escape(room)}"]`);
  const badge = document.querySelector(`[data-badge="${CSS.escape(room)}"]`);
  if (!logEl) return;
  const buf = buffers.get(room) || [];
  badge.textContent = String(buf.length);
  logEl.innerHTML = buf.map(m =>
    `<div class="line"><time>[${fmtTime(m.ts)}]</time><span class="from">${escapeHtml(m.from||'•')}</span>${escapeHtml(m.text||'')}</div>`
  ).join('');
  logEl.scrollTop = logEl.scrollHeight;
}

function push(room, msg){
  if (!buffers.has(room)) buffers.set(room, []);
  const buf = buffers.get(room);
  buf.push(msg);
  if (buf.length > MAX_LINES) buf.splice(0, buf.length - MAX_LINES);
  if (!paused.get(room)) paintRoom(room);
}

/* ======== data loading ======== */
async function hydrateRoom(room, force=false) {
  if (!logsToken()) return;
  if (hydrated.get(room) && !force) return;
  try {
    const r = await fetch(httpBase() + '/logs.json?room=' + encodeURIComponent(room), {
      cache:'no-store',
      headers:{ 'x-logs-token': logsToken() }
    });
    const j = await r.json();
    if (Array.isArray(j.messages)) {
      buffers.set(room, j.messages.slice(-MAX_LINES)); // backfill
      paintRoom(room);
      hydrated.set(room, true);
    }
  } catch {}
}

function connectRoom(room){
  if (!logsToken()) return;
  if (!sockets.has(room)) {
    hydrateRoom(room);
    const wsUrlBase = httpToWs(httpBase());
    const url = new URL(wsUrlBase);
    url.searchParams.set('room', room);
    url.searchParams.set('name', 'Monitor');
    url.searchParams.set('token', logsToken()); // pass logs token to WS
    const ws = new WebSocket(url.toString());
    sockets.set(room, ws);
    ensureRoomCard(room);

    ws.onopen = () => { push(room, {ts: Date.now(), from:'•', text:`[monitor] connected to ${room}`}); };
    ws.onmessage = (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.type === 'msg') {
          push(room, {ts: data.ts || Date.now(), from: data.from || '??', text: data.text || ''});
        } else if (data.type === 'system') {
          push(room, {ts: Date.now(), from:'•', text: data.text || ''});
        }
      } catch {
        push(room, {ts: Date.now(), from:'•', text: String(ev.data||'')});
      }
    };
    ws.onclose = () => { push(room, {ts: Date.now(), from:'•', text:'[monitor] disconnected'}); sockets.delete(room); };
    ws.onerror = () => { push(room, {ts: Date.now(), from:'•', text:'[monitor] error'}); };
  }
}

function reconnectRoom(room){
  const ws = sockets.get(room);
  if (ws) { try{ ws.close(); }catch{} }
  sockets.delete(room);
  connectRoom(room);
}

async function loadConnectionsAndRooms() {
  updateLocks();

  const roomFilter = filterInput.value.trim();
  const qs = roomFilter ? ('?room=' + encodeURIComponent(roomFilter)) : '';

  // 1) connections table (gated)
  if (connToken()){
    try {
      const r = await fetch(httpBase() + '/connections.json' + qs, {
        cache:'no-store',
        headers:{ 'x-conn-token': connToken() }
      });
      const j = await r.json();
      tableBody.innerHTML = '';
      (j.clients || []).forEach((c, i) => {
        const tr = document.createElement('tr');
        const key = c.key || '';
        const keyShort = key ? (key.slice(0,8) + '…' + key.slice(-4)) : '';
        tr.innerHTML =
            '<td>' + (i+1) + '</td>'
          + '<td>' + escapeHtml(c.room || '') + '</td>'
          + '<td>' + escapeHtml(c.name || '') + '</td>'
          + '<td>' + escapeHtml(c.ip || '') + '</td>'
          + '<td>' + (key ? ('<code title="'+escapeHtml(key)+'">'+escapeHtml(keyShort)+'</code>') : '—') + '</td>';
        tableBody.appendChild(tr);
      });
      if (typeof j.count === 'number') document.title = 'Chat Admin ('+ j.count +')';
    } catch (e) {
      tableBody.innerHTML = '<tr><td colspan="6" class="muted">Failed to load (check Connections Token)</td></tr>';
    }
  }

  // 2) rooms list -> ensure monitors/reconnect (gated)
  if (logsToken()){
    try {
      const rr = await fetch(httpBase() + '/rooms.json', {
        cache:'no-store',
        headers:{ 'x-conn-token': connToken() } // if your server wants conn token to list rooms; keep or remove
      });
      const jr = await rr.json();
      const set = new Set((jr.rooms || []));
      const f = filterInput.value.trim();
      if (f) { for (const r of Array.from(set)) if (!r.includes(f)) set.delete(r); }
      set.forEach(room => { ensureRoomCard(room); connectRoom(room); });
    } catch (e) {
      // leave grid empty; lock box already visible
    }
  }
}

setInterval(loadConnectionsAndRooms, 2000);
updateLocks();
loadConnectionsAndRooms();

/* ======== Keys UI (existing) ======== */
genKeyBtn.addEventListener('click', async ()=>{
  const label = keyLabel.value.trim();
  if (!label) { keyMsg.textContent = 'Enter a label'; return; }
  keyMsg.textContent = 'Creating...';
  try{
    const r = await fetch(httpBase() + '/admin/keys', {
      method:'POST',
      headers:{ 'x-admin-token': token(), 'content-type':'application/json' },
      body: JSON.stringify({ label })
    });
    if (!r.ok) throw new Error('unauthorized or server error');
    const j = await r.json();
    keyMsg.textContent = 'Key created ✔ (copied)';
    try { await navigator.clipboard.writeText(j.key); } catch {}
    keyLabel.value = '';
    await loadKeys();
  }catch(e){
    keyMsg.textContent = 'Error: ' + (e.message || 'failed');
  } finally {
    setTimeout(()=> keyMsg.textContent = '', 2000);
  }
});

refreshKeysBtn.addEventListener('click', loadKeys);
keyFilter.addEventListener('input', ()=> renderKeys(window.__keysCache || []));

async function loadKeys(){
  keyMsg.textContent = 'Loading...';
  try{
    const r = await fetch(httpBase() + '/admin/keys', {
      headers:{ 'x-admin-token': token() }
    });
    if (!r.ok) throw new Error('unauthorized or server error');
    const j = await r.json();
    window.__keysCache = Array.isArray(j) ? j : [];
    renderKeys(window.__keysCache);
    keyMsg.textContent = 'Loaded ✔';
  }catch(e){
    keyMsg.textContent = 'Error: ' + (e.message || 'failed');
  } finally{
    setTimeout(()=> keyMsg.textContent = '', 1500);
  }
}

function renderKeys(list){
  const q = keyFilter.value.trim().toLowerCase();
  const rows = (list || []).filter(k=>{
    if (!q) return true;
    return (k.label||'').toLowerCase().includes(q) || (k.key||'').toLowerCase().includes(q);
  }).sort((a,b)=> String(b.createdAt||'').localeCompare(String(a.createdAt||'')));

  keysTbody.innerHTML = '';
  rows.forEach(k=>{
    const tr = document.createElement('tr');
    const created = k.createdAt ? new Date(k.createdAt).toLocaleString() : '';
    tr.innerHTML = `
      <td>${escapeHtml(k.label || '')}</td>
      <td class="small">${escapeHtml(k.key || '')}</td>
      <td>${k.revoked ? '<span class="pill revoked">revoked</span>' : '<span class="pill active">active</span>'}</td>
      <td class="small">${escapeHtml(created)}</td>
      <td class="nowrap">
        <button data-copy>Copy</button>
        ${k.revoked ? '' : '<button data-revoke class="btn-danger">Revoke</button>'}
      </td>
    `;
    tr.querySelector('[data-copy]').addEventListener('click', async ()=>{
      try { await navigator.clipboard.writeText(k.key); keyMsg.textContent = 'Copied ✔'; } catch { keyMsg.textContent = 'Copy failed'; }
      setTimeout(()=> keyMsg.textContent = '', 1200);
    });
    const rev = tr.querySelector('[data-revoke]');
    if (rev) rev.addEventListener('click', async ()=>{
      if (!confirm('Revoke this key? Active users will be kicked.')) return;
      try{
        const r = await fetch(httpBase() + '/admin/keys', {
          method:'DELETE',
          headers:{ 'x-admin-token': token(), 'content-type':'application/json' },
          body: JSON.stringify({ key: k.key })
        });
        if (!r.ok) throw new Error('server error');
        await loadKeys();
      }catch(e){ keyMsg.textContent = 'Error revoking'; setTimeout(()=> keyMsg.textContent='', 1500); }
    });
    keysTbody.appendChild(tr);
  });
}

// initial keys load (if token is already saved)
if (token()) loadKeys();
</script>
</body>
</html>
